---
title: "INE"
author: "João Dionísio"
date: "February 2023"
format:
  html:
    smooth-scroll: true
    self-contained: true
    toc: true
    toc-location: left
theme: cosmo
smooth-scroll: true
execute:
  warning: false
project:
  output-dir: outputs/documents
---

## Packages

```{r}
install.packages('jsonlite', dependencies=TRUE, repos='http://cran.rstudio.com/')
library(jsonlite)

install.packages("tidyverse", dependencies=TRUE, repos='http://cran.rstudio.com/')
library(tidyverse)

install.packages("readxl", dependencies=TRUE, repos='http://cran.rstudio.com/')
library(readxl)

install.packages("data.table", dependencies=TRUE)
library("data.table")
```

## Fetch Datasets

All datasets from INE - Bulky - still needs works

Passos para extração em código:

1.  Extração dos indicadores do INE

2.  Filtro para os que estão disponíveis do portal

3.  Destes o ideal será escolher alguns e filtrar por esses - ainda não implementado

4.  Depois teremos duas opções:

    1.  Extração do último ano ou últimos anos com todos os dados- ainda não implementado

        1.  Limitações de linhas

    2.  Extração por municipios ou áreas desejadas - ver Dim

```{r}
library(readxl)
Indicadores <- read_excel("datasets/Indicadores.xlsx", skip = 14)

Indicadores <- Indicadores %>%
  filter(`Disponível no Portal`== "Sim")
```

```{r}

https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0011613&Dim1=T&lang=PT

numbers <- Indicadores$`Código de difusão`
l <- length(numbers)

for(i in 1:5 ){
    result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0008614","&Dim1=T&lang=PT"))
  if (!("IndicadorCod" %in% colnames(result))) {
    numbers <- numbers[-i]
    l <- l - 1
    i <- i - 1
  } else {
    assign(result$IndicadorDsg,as.data.frame(result$Dados))
    d1 <- unnest_longer(result$Dados,col = colnames(result$IndicadorDsg),names_repair = "minimal")
    write_csv(d2,file = paste0("datasets/",numbers[i],".csv"))
  }
   if (i %% 100 == 0) {
      Sys.sleep(60)
  }
}
```

# First Test

## Pop censitária - 2021

População por municipio à data do CENSUS 2021

```{r}
# codigos_df <- read_excel("datasets/ref_geo.xlsx")
# 
# 
# numbers <- codigos_df$last4
# 
# l <- length(numbers)
# for(i in 1:l ){
#     result<- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0011626&Dim1=T&Dim2=",numbers[i],"&lang=PT"))
#     pop <- as.data.frame(result$Dados$'2021')
#    if (i %% 99 == 0) {
#       Sys.sleep(15)
#    }
#   if(i==1){
#   d2 <- pop
#   }else{
#     d2 <- rbind(d2,pop)
#   }
# }
# 
# d2 <- d2 %>%
#   mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))
# 
# fwrite(d2,file = paste0("datasets/pop_base_2021.csv"), bom = T)

```

# Improvements

## Linkage geo

Vlookup in R - Merge function

```{r}
linkage_geo <- read_csv("datasets/linkage_geo.csv")%>%  
  mutate(last_4 = as.character(substr(cod_geo, nchar(cod_geo)-3,nchar(cod_geo))))

linkage_geo_freg <- read_csv2("datasets/categorias_geo_freg.csv")%>%
  select(-municip)%>%
  rename(last_4 =pair)%>%
  left_join(linkage_geo,by = "last_4")

linkage_geo <- linkage_geo %>%
  select(geo, ars, nuts3, aces2, nuts1, nuts2, cod_geo_nuts2002, cod_geo)%>%
  rename(municip="geo")%>%
  mutate(municip= recode(municip, "Calheta"="Calheta [R.A. Madeira]"))%>%
  rename(geocod = "cod_geo")
```

Pivot Individual

```{r}

# d3 <- d2%>%
#   select(-dim_3,-dim_4)%>%
#   pivot_wider(names_from = dim_4_t,values_from = valor)%>%
# 
# write_csv(d3,file = paste0("datasets/pop_base_2021_anos.csv"))
```

Pivot quinquenal

```{r}
# d2$dim_4 <- as.numeric(d2$dim_4)
# d2$valor <- as.numeric(d2$valor)
# #grupos etários
# gr_1  <- c(1)        #<1 ano
# gr_2  <- c(2:5)    #0 - 4 anos
# gr_3  <- c(6:10)   #5 - 9 anos
# gr_4  <- c(11:15)  #10 - 14 anos
# gr_5  <- c(16:20)  #15 - 19 anos
# gr_6  <- c(21:25)  #20 - 24 anos
# gr_7  <- c(26:30)  #25 - 29 anos
# gr_8  <- c(31:35)  #30 - 34 anos
# gr_9  <- c(36:40)  #35 - 39 anos
# gr_10 <- c(41:45)  #40 - 44 anos
# gr_11 <- c(46:50) #45 - 49 anos
# gr_12 <- c(51:55)  #50 - 55 anos
# gr_13 <- c(56:60)  #56 - 59 anos
# gr_14 <- c(61:65)  #60 - 65 anos
# gr_15 <- c(66:70)  #65 - 69 anos
# gr_16 <- c(71:75)  #70 - 74 anos
# gr_17 <- c(76:80)  #75 - 80 anos
# gr_18 <- c(81:85)  #81 - 85 anos
# gr_19 <- c(86:101)  #85 e mais anos
# gr_20 <- c("T")  #Totais
# 
# munucip_pop_age <- d2 %>%
#   mutate(etario = case_when(
#     dim_4 %in% gr_1 ~ "<1 ano"
#     ,dim_4 %in% gr_2 ~ "0 - 4 anos"
#     ,dim_4 %in% gr_3 ~ "5 - 9 anos"
#     ,dim_4 %in% gr_4 ~ "10 - 14 anos"
#     ,dim_4 %in% gr_5 ~ "15 - 19 anos"
#     ,dim_4 %in% gr_6 ~ "20 - 24 anos"
#     ,dim_4 %in% gr_7 ~ "25 - 29 anos"
#     ,dim_4 %in% gr_8 ~ "30 - 34 anos"
#     ,dim_4 %in% gr_9 ~ "35 - 39 anos"
#     ,dim_4 %in% gr_10 ~ "40 - 44 anos"
#     ,dim_4 %in% gr_11 ~ "45 - 49 anos"
#     ,dim_4 %in% gr_12 ~ "50 - 54 anos"
#     ,dim_4 %in% gr_13 ~ "55 - 59 anos"
#     ,dim_4 %in% gr_14 ~ "60 - 64 anos"
#     ,dim_4 %in% gr_15 ~ "65 - 69 anos"
#     ,dim_4 %in% gr_16 ~ "70 - 74 anos"
#     ,dim_4 %in% gr_17 ~ "75 - 80 anos"
#      ,dim_4 %in% gr_18 ~ "81 - 84 anos"
#      ,dim_4 %in% gr_19 ~ "85 e mais anos"
#      ,dim_4 %in% gr_20 ~ "Total"
#    )) %>%
#    select(-dim_4,-dim_3,-dim_4_t)%>%
#    group_by(etario)%>%
#    pivot_wider(names_from = etario,values_from = valor, values_fn =sum)%>%
#    rename(Total = "NA")%>%
#    replace(is.na(.),0)%>%
#    left_join(linkage_geo, by = "municip")
# 
#  #Reordenar colunas
#  munucip_pop_age2 <- munucip_pop_age[,c(1,2,3,4,24,25,26,27,6,11,15,9,7,8,21,16,10,13,18,14,17,19,12,23,22,5,20)]
# #
#  munucip_pop_age2 <- munucip_pop_age2%>%
#    filter(dim_3_t == "H" | dim_3_t == "M" )
# #
#  munucip_pop_age <- d2 %>%
#    mutate(etario = case_when(
#      dim_4 %in% gr_1 ~ "<1 ano"
#     ,dim_4 %in% gr_2 ~ "0 - 4 anos"
#     ,dim_4 %in% gr_3 ~ "5 - 9 anos"
#     ,dim_4 %in% gr_4 ~ "10 - 14 anos"
#     ,dim_4 %in% gr_5 ~ "15 - 19 anos"
#     ,dim_4 %in% gr_6 ~ "20 - 24 anos"
#     ,dim_4 %in% gr_7 ~ "25 - 29 anos"
#      ,dim_4 %in% gr_8 ~ "30 - 34 anos"
#      ,dim_4 %in% gr_9 ~ "35 - 39 anos"
#      ,dim_4 %in% gr_10 ~ "40 - 44 anos"
#      ,dim_4 %in% gr_11 ~ "45 - 49 anos"
#      ,dim_4 %in% gr_12 ~ "50 - 54 anos"
#      ,dim_4 %in% gr_13 ~ "55 - 59 anos"
#      ,dim_4 %in% gr_14 ~ "60 - 64 anos"
#      ,dim_4 %in% gr_15 ~ "65 - 69 anos"
#      ,dim_4 %in% gr_16 ~ "70 - 74 anos"
#      ,dim_4 %in% gr_17 ~ "75 - 80 anos"
#      ,dim_4 %in% gr_18 ~ "81 - 84 anos"
#      ,dim_4 %in% gr_19 ~ "85 e mais anos"
#      ,dim_4 %in% gr_20 ~ "Total"
#   )) %>%
#     select(-dim_4,-dim_3,-dim_4_t)%>%
#    filter(dim_3_t %in% c("H", "M") & is.na(etario)==FALSE)%>%
#    rename(populacao = valor, sexo = dim_3_t )%>%
#    group_by(geocod,municip,sexo,etario )%>%
#    summarise(populacao= sum(populacao))%>%
#   left_join(linkage_geo, by = "municip")
# 
# 
# 
#  fwrite(munucip_pop_age,file = paste0("outputs/munucip_pop_age_long.csv"), bom = T)
# fwrite(munucip_pop_age2,file = paste0("outputs/munucip_pop_age_wide.csv"), bom = T)
```

## Maria - Indicador 0008273 -Done

População residente (N.º) por Local de residência (NUTS - 2013), Sexo e Grupo etário; Anual - 2011- 2020

```{r}
# codigos_df <- read_excel("datasets/ref_geo.xlsx")
# # &Dim2=", numbers[i], "
# numbers <-linkage_geo$cod_geo
# 
# anos_cod <- c("pop_2011","pop_2012","pop_2013","pop_2014","pop_2015","pop_2016","pop_2017","pop_2018","pop_2019","pop_2020")
# 
# years <- c("2011","2012","2013","2014","2015","2016","2017","2018","2019","2020")
# 
# l <- length(numbers)
# 
# y <- length(years)
# 
# t <- length(anos_cod)
# 
# result_list <- list()
# 
# for (i in 1:l) {
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0008273&Dim1=T&Dim2=", numbers[i],"&lang=PT"))
#   for (i in 1:y) {
#     pop <- as.data.frame(result$Dados)
#     pop <- pop %>%
#           unnest(years[i])%>%
#           select(geocod,geodsg,dim_3,dim_3_t,dim_4,dim_4_t,valor)
#     result_list[[anos_cod[i]]] <- rbind(result_list[[anos_cod[i]]], pop)
#   }
#   if (i %% 100 == 0) {
#     Sys.sleep(60)
#   }
#   Sys.Sleep(2)
# }
# for (i in 1:y) {
#   assign(anos_cod[i], result_list[[anos_cod[i]]])%>% mutate(municip = case_when(
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%fwrite(file = paste0("outputs/",anos_cod[i],".csv"), bom = T)
# }

```

## Maria - Indicador 0003182 - Done

```{r}
# 
# numbers <-linkage_geo$cod_geo_nuts2002
# numbers
# 
# anos_cod <- c("pop_2001","pop_2002","pop_2003","pop_2004","pop_2005","pop_2006","pop_2007","pop_2008","pop_2009","pop_2010")
# 
# years <- c("2001","2002","2003","2004","2005","2006","2007","2008","2009","2010")
# 
# l <- length(numbers)
# 
# y <- length(years)
# 
# result_list <- list()
# 
# for (i in 1:l) {
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0003182&Dim1=T&Dim2=", numbers[i], "&lang=PT"))
#   for (i in 1:y) {
#     pop <- as.data.frame(result$Dados)
#     pop <- pop %>%
#           unnest(years[i])%>%
#           select(geocod,geodsg,dim_3,dim_3_t,dim_4,dim_4_t,valor)
#     result_list[[anos_cod[i]]] <- rbind(result_list[[anos_cod[i]]], pop)
#   }
#   if (i %% 100 == 0) {
#     Sys.sleep(60)
#   }
# }
# for (i in 1:y) {
#   assign(anos_cod[i], result_list[[anos_cod[i]]])%>% mutate(municip = case_when(
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%fwrite(file = paste0("outputs/",anos_cod[i],".csv"), bom = T)
# }
```

# Extrator Universal de Indicadores do INE para Diagnóstico - Municipio, NUTSIII, NUTSII e NUTSI - V2.0 - Faster, Stronger, Better

O que é suposto:

Definir indicadores a extrair - variável indicador - colocar entre aspas

Pode ser possível extrair os últimos x observacoes - Definido pela variável X

```{r}
# linkage_geo <- read_csv("datasets/linkage_geo.csv")
#   
# linkage_geo <- linkage_geo %>%  
#   select(geo, ars, nuts3, aces2, nuts1, nuts2, cod_geo_nuts2002, cod_geo)  %>%
#   rename(municip="geo")%>%
#   mutate(municip= recode(municip, "Calheta"="Calheta [R.A. Madeira]"))

Indicadores <- read_excel("datasets/Indicadores.xlsx", skip = 14)

Indicadores <- Indicadores %>%
  filter(`Disponível no Portal`== "Sim")

#indicador <- Indicadores$`Código de difusão`

#DEFINIR INDICADORES A RETIRAR

indicador <- c("0008614","0009817") 

#TERMO DE DESAGREGACAO POR LOCALIZACAO GEOGRAFICA
desag <- "&Dim2="

#CODIGOS GEOGRAFICOS NUTSIII PARA 2012 e 2002
cod_2002 <-linkage_geo$cod_geo_nuts2002
cod_2002 <- cod_2002[! cod_2002 %in% c("9999999", "0")]
cod_2014 <- linkage_geo$geocod
cod_2014 <- cod_2014[! cod_2014 %in% c("9999999", "0")]

#CODIGOS PARA NUTSII
nuts_ii_cod <- c("PT","11","16","17","18","19","20","30")

#Minimo 2
obs_back <- 10

# DEFINICOES BASEADO NO COLOCADO EM CIMA

a <- length(indicador)

b <- length(cod_2014) 

c <- length(nuts_ii_cod)

#A API DO INE TEM UM LIMITE DE REQUESTS LOGO E CRIADO UM VALOR QUE VAI AUMENTANDO COM AS REQUESTS QUE SAO FEITAS
 
counter <- 1

#LIMPA A ESTRACAO ANTERIOR
result_list <- list()

#FUNCAO DE SLEEP - funciona se sleep e 60, 30, 20, 10, 

sleep <- function(z){
  if (z %% 100 == 0) {
    Sys.sleep(5)
    z <- 1
  }else{
      z <- z+1
  }
} 
```

```{r}
# save_to_result_list <- function(y){
#   #Segundo loop baseado na desagregação maxima conseguida
#     colunas_nanos <- colnames(dados)
#     num_colunas <- length(colunas_nanos)
#     obs_back  <- as.numeric(colunas_nanos[num_colunas])
#     if(year_back > num_colunas){
#         x <- num_colunas
#     }else{
#       x <-  year_back
#     }
#     obs_back s <- as.character(c((obs_back -x):(obs_back )))
#     each_df <- y %>%
#       select(obs_back s[1])%>%
#       unnest(obs_back s[1])
#     colunas_por_ano <- colnames(each_df)
#     for (i in 1:x) {
#     #ver e retirar os nomes das colunas de cada ano para o select
#     dados1 <- dados %>%
#         unnest(obs_back s[i])%>%
#         select(all_of(colunas_por_ano))
#     result_list[[obs_back s[i]]] <- rbind(result_list[[obs_back s[i]]], dados1)
#     }
#     return(obs_back )
#     return(x)
#     return(result_list)
# }
# 
# write_output <- function(v){
#   x <- length(as.data.frame(v))
#   for (i in 1:x) {
#     nomedf <- paste0(indicador_atual,"_",obs_back s[i],"_",agreg)
#     full_df <- v[[obs_back s[i]]]%>% 
#       mutate(municip = case_when(
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]", 
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#       fwrite(file = paste0("outputs/",nomedf,".csv"), bom = T)
#   }
#   result_list <- list()
# }
# 
```

Bugs:

Erro em colunas cujo formato não seja Dados\$anos

-   Mudar para um sistema de referência (penultima coluna, antepenultima coluna for example)

    -   Resolvido - obs_backs \<- as.character(c(colunas_nanos\[(num_colunas-x):(num_colunas)\]))

-   Mudar para Numero de observações

    -   Resolvido - obs_back \<- 5

-   Erro quando colunas diferentes em diferentes anos (sigh)

    -   Resolvido - Bind_rows e refefinir como selecionar as colunas

-   Pensar em Refazer com o flatten command

    -   Ainda por resolver\_

-   Para já o left join esta com o geocod

```{r, echo = TRUE}
#Falta codigo de debugging

for (k in 1:a) {
  #COMECA POR LER O INDICADOR A RETIRAR
  indicador_atual <- indicador[k]
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO DE 2014
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_2014[79], "&lang=PT"))
  result <- as.data.frame(result)
  #OS DADOS DO INE VEM COM MI E DADOS - PARA A EXTRACAO
  if (("IndicadorCod" %in% colnames(result))){ 
  for (w in 1:b) {
  #retirar indicador com desagregação municipio 2014
  counter <- sleep(counter)
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_2014[w], "&lang=PT"))
  agreg <- "NUTSIII"
  dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_backs <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_backs2 <-  obs_backs[-i]
    dados1 <- dados %>%
        unnest(obs_backs[i])%>%
        select(-all_of(obs_backs2))
    result_list[[obs_backs[i]]] <- bind_rows(result_list[[obs_backs[i]]], dados1)
  Sys.sleep(1)
    }}
    if (w %% 100 == 0) {
      print(cod_2014[w])
   }
    }
  else if(length(result_list)==0){
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO DE 2002
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",desag, cod_2002[1], "&lang=PT"))
  result <- as.data.frame(result)
  if (("IndicadorCod" %in% colnames(result))) {
  #retirar indicador com desagregação municipio 2002
  for (e in 1:b) {
  counter <- sleep(counter)
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",desag, cod_2002[e], "&lang=PT"))
  agreg <- "NUTSIII"
  dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_backs <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_backs2 <-  obs_backs[-i]
    dados1 <- dados %>%
        unnest(obs_backs[i])%>%
        select(-all_of(obs_backs2))
    result_list[[obs_backs[i]]] <- bind_rows(result_list[[obs_backs[i]]], dados1)
  Sys.sleep(1)
    }}
    if (e %% 100 == 0) {
      print(cod_2014[e])
   }
  }
  }
  else if(length(result_list)==0){
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO DE NUTSII
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",desag, nuts_ii_cod[1], "&lang=PT"))
  result <- as.data.frame(result)
  if (("IndicadorCod" %in% colnames(result))) {
  #retirar indicador com desagregação NUTSII
  for (r in 1:c) {
  counter <- sleep(counter)
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual ,"&Dim1=T",desag, nuts_ii_cod[r], "&lang=PT"))
  agreg <- "NUTSII"
  dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_backs <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_backs2 <-  obs_backs[-i]
    dados1 <- dados %>%
        unnest(obs_backs[i])%>%
        select(-any_of(obs_backs2))
    result_list[[obs_backs[i]]] <- bind_rows(result_list[[obs_backs[i]]], dados1)
  Sys.sleep(1)
    }}
  }
  }
  else{
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO NACIONAL OU FORA DO PADRAO
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T&lang=PT"))
  if (("IndicadorCod" %in% colnames(result))) {
  #retirar indicador sem desagragação
  agreg <- "nacional"
  result <- as.data.frame(result)
   dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_backs <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_backs2 <-  obs_backs[-i]
    dados1 <- dados %>%
        unnest(obs_backs[i])%>%
        select(-all_of(obs_backs2))
    result_list[[obs_backs[i]]] <- bind_rows(result_list[[obs_backs[i]]], dados1)
  Sys.sleep(1)
    }}
  }
  if (length(result_list)!=0){
     x <- length(result_list)
    for (i in 1:x) {
      nomedf <- paste0(indicador_atual,"_",obs_backs[i],"_",agreg)
      assign(paste0("full_df"), as.data.frame(result_list[[obs_backs[i]]])%>% 
      select(-any_of(colunas_nanos))%>%left_join(linkage_geo, by="geocod"))
      fwrite(full_df, file = paste0("outputs/",nomedf,".csv"), bom = T)
  }
  }
  if (k == k) {
    print(indicador_atual)
    result_list <- list()
   }
}
```

## Testing a rejoin code

```{r}
# Get a list of file names
file_names <- list.files(path = "outputs", pattern = ".*\\.csv")

# Initialize a list to store the data frames
df_list <- list()
#FOR LOOP
for (file_name in file_names) {
  # Split the file name into its components
  components <- strsplit(file_name, c("_"))[[1]]
  
    # Remove the ".csv" extension from the last component
  last_component <- sub(".csv", "", components[length(components)])
  components[length(components)]
  # Replace the last component in the components vector
  components[length(components)] <- last_component
  # Assign the components to variables
  indicador <- components[1]
  year <- components[2]
  aggregation <- components[3]
  
  # Load the file into a data frame
  df <- read.csv(file.path("outputs", file_name))
  
  # Add columns for year and aggregation
  df <- cbind(df, year = year, aggregation = aggregation)
  
  # Check if a data frame for this indicator already exists
  if (!(indicador %in% names(df_list))) {
    # If not, create a new data frame for this indicator
    df_list[[indicador]] <- df
  } else {
    # If it does, use rbind to combine the data frames
    df_list[[indicador]] <- rbind(df_list[[indicador]], df)
  }
}

# Write each data frame to a separate CSV file
for (df_name in names(df_list)) {
  df <- df_list[[df_name]]
  write.csv(df, file.path("outputs", paste0(df_name, ".csv")))
}



#MAP FUNCTION DOES NOT WORK

# # Use map to process each file name
# map(file_names, function(file_name, df_list) {
#   # Split the file name into its components
#   components <- strsplit(file_name, "_")[[1]]
#   
#   # Assign the components to variables
#   indicador <- components[1]
#   year <- components[2]
#   aggregation <- components[3]
#   
#   # Load the file into a data frame
#   df <- read.csv(file.path("outputs", file_name))
#   
#   # Add columns for year and aggregation
#   df <- cbind(df, year = year, aggregation = aggregation)
#   # Check if a data frame for this indicator already exists
#   if (!(indicador %in% names(df_list))) {
#     # If not, create a new data frame for this indicator
#     df_list[[indicador]] <- df
#   } else {
#     # If it does, use rbind to combine the data frames
#     df_list[[indicator]] <- rbind(df_list[[indicator]], df)
#   }
# }, df_list)
```

## Extrator Universal para indicadores com Freguesia - Confirmar - Ainda por fazer - ponderar fazer?

```{r}
# Get a list of file names


# linkage_geo_freg <- read_csv2("datasets/categorias_geo_freg.csv")%>%
#   select(-municip)%>%
#   rename(last_4 =pair)%>%
#   left_join(linkage_geo,by = "last_4" )
# 
# 
# cod_6 <- linkage_geo_freg$Código
# 
# indicador <- c("0003182")
# 
# for (i in 1:a) {
#   indicador_atual <- indicador[i]
#   counter <- sleep(counter)
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_6[79], "&lang=PT"))
#   result <- as.data.frame(result)
#   if (("IndicadorCod" %in% colnames(result))){ 
#   for (w in 1:b) {
#   #retirar indicador com desagregação municipio 2014
#   counter <- sleep(counter)
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_6[w], "&lang=PT"))
#   agreg <- "freguesia"
#   result <- as.data.frame(result)
#   colunas_nanos <- colnames(dados)
#     num_colunas <- length(colunas_nanos)
#     obs_back  <- as.numeric(colunas_nanos[num_colunas])
#     if(year_back > num_colunas){
#         x <- num_colunas
#     }else{
#       x <-  year_back
#     }
#     obs_back s <- as.character(c((obs_back -x):(obs_back )))
#     each_df <- y %>%
#       select(obs_back s[1])%>%
#       unnest(obs_back s[1])
#     colunas_por_ano <- colnames(each_df)
#     for (i in 1:x) {
#     #ver e retirar os nomes das colunas de cada ano para o select
#     dados1 <- dados %>%
#         unnest(obs_back s[i])%>%
#         select(all_of(colunas_por_ano))
#     result_list[[obs_back s[i]]] <- rbind(result_list[[obs_back s[i]]], dados1)
#   Sys.sleep(2)
#     }}
#     if (w %% 100 == 0) {
#       print(cod_6[w])
#    }
#     }
#   else{
#   counter <- sleep(counter)
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T&lang=PT"))
#   if (("IndicadorCod" %in% colnames(result))) {
#   #retirar indicador sem desagragação
#   agreg <- "nacional"
#   result <- as.data.frame(result)
#     dados <- as.data.frame(result$Dados)
#   colunas_nanos <- colnames(dados)
#     num_colunas <- length(colunas_nanos)
#     obs_back  <- as.numeric(colunas_nanos[num_colunas])
#     if(year_back > num_colunas){
#         x <- num_colunas
#     }else{
#       x <-  year_back
#     }
#     obs_back s <- as.character(c((obs_back -x):(obs_back )))
#     each_df <- dados %>%
#       select(obs_back s[1])%>%
#       unnest(obs_back s[1])
#     colunas_por_ano <- colnames(each_df)
#     for (i in 1:x) {
#     #ver e retirar os nomes das colunas de cada ano para o select
#     dados1 <- dados %>%
#         unnest(obs_back s[i])%>%
#         select(all_of(colunas_por_ano))
#     result_list[[obs_back s[i]]] <- rbind(result_list[[obs_back s[i]]], dados1)
#   Sys.sleep(2)
#   }
#   }
#   }
#   if (length(result_list)!=0){
#      x <- length(result_list)
#     for (i in 1:x) {
#       nomedf <- paste0(indicador_atual,"_",obs_back s[i],"_",agreg)
#       full_df <- result_list[[obs_back s[i]]]%>% 
#       fwrite(file = paste0("outputs/",nomedf,".csv"), bom = T)
#   }
#   }
#   if (i == i) {
#       print(indicador_atual)
#    }
# }
```
