---
title: "INE"
author: "João Dionísio"
date: "February 2023"
format:
  html:
    smooth-scroll: true
    self-contained: true
    toc: true
    toc-location: left
theme: cosmo
smooth-scroll: true
execute:
  warning: false
project:
  output-dir: outputs/documents
---

## Packages

```{r, include=FALSE}
#install.packages('jsonlite', dependencies=TRUE, repos='http://cran.rstudio.com/')
library(jsonlite)

#install.packages("tidyverse", dependencies=TRUE, repos='http://cran.rstudio.com/')
library(tidyverse)

locale("pt")
# install.packages("readxl", dependencies=TRUE, repos='http://cran.rstudio.com/')
library(readxl)

# install.packages("data.table")
library(data.table)

# install.packages("shiny")
library(shiny)
```

## Fetch Datasets

All datasets from INE - Bulky - still needs works

Passos para extração em código:

1.  Extração dos indicadores do INE

2.  Filtro para os que estão disponíveis do portal

3.  Destes o ideal será escolher alguns e filtrar por esses - ainda não implementado

4.  Depois teremos duas opções:

    1.  Extração do último ano ou últimos anos com todos os dados- ainda não implementado

        1.  Limitações de linhas

    2.  Extração por municipios ou áreas desejadas - ver Dim

```{r, include=FALSE}
library(readxl)
Indicadores <- read_excel("INE_API/datasets/Indicadores.xlsx", skip = 14)

Indicadores <- Indicadores %>%
  filter(`Disponível no Portal`== "Sim")
, ordered= TRUE

graph_test <- X0009817 %>%
  filter(aces2=="ACeS Baixo Mondego")%>%
  mutate(valor = as.numeric(valor))%>%
  mutate(year2 = str_sub(year,-4))%>%
  arrange(year2, year)

ggplot() +
  geom_line(data = graph_test, aes(x = factor(year, levels=unique(year),ordered= TRUE)
                                   ,y = as.numeric(valor), colour = geodsg, group= geodsg), linewidth = 1.2) +
  scale_x_discrete(guide = guide_axis(angle = 90))+
  scale_color_hue(direction = 1) +
  coord_cartesian(expand = FALSE)+
  labs(
    x = "Observações",
    y = "Valor",
    title = "Teste",
    caption = "Fonte dos Dados:INE",
    color = "Localização Geográfica"
  ) +
  theme_minimal()

length(unique(graph_test$year))
```

Exemplo Simples de como funciona a app

```{r, eval=FALSE}
#| code-fold: true
#| code-summary: "Mostrar Código"
# https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0011613&Dim1=T&lang=PT
meta_list <- list()
indicators <- c("0008614","0009817")
sleep <- function(z) {
  if (z %% 100 == 0) {
    Sys.sleep(5)
    z <- 1
  } else {
    z <- z + 1
  }
  return(z)
}

# results_raw <- fromJSON(
#       paste0(
#         "https://www.ine.pt/ine/json_indicador/pindicaMeta.jsp?varcd=",
#         "0008614",
#         "&lang=PT"
#       ))
names(model_arima)
ine.meta(indicators, meta_list)

ine.meta <- function(indicators, meta_list){
  counter <- 0
  for (i in 1:length(indicators)) {
    # Get the current indicator
    counter <- sleep(counter)
    indicators_current <- indicators[i]
    # Call the sleep function
    counter <- sleep(counter)
    # meta_list[[descricao]]
    results_raw <- fromJSON(
      paste0(
        "https://www.ine.pt/ine/json_indicador/pindicaMeta.jsp?varcd=",
        indicators_current,
        "&lang=PT"
      ))
    names <- results_raw %>% select(!c(Dimensoes,Sucesso))%>% pivot_longer(everything(), names_to = "Nome" , values_to = "Descricao")
    notas <- results_raw%>%
      unnest(Dimensoes)%>%
      select(Descricao_Dim)%>%
      unnest(Descricao_Dim)%>%
      select(!dim_num)%>%
      rename("Nome" = abrv , "Descricao" = versao)
    
    final_result <- bind_rows(names,notas)
    
    meta_list[[indicators_current]]<- final_result
  }
  return(meta_list)
}
  
a <- fromJSON(
      paste0(
        "https://www.ine.pt/ine/json_indicador/pindicaMeta.jsp?varcd=0005611",
        "&lang=PT"
      ))%>%
  select(!c(Dimensoes,Sucesso))
         
colnames(a)

numbers <- Indicadores$`Código de difusão`
l <- length(numbers)

for(i in 1:5 ){
    result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0008614","&Dim1=T&lang=PT"))
  if (!("IndicadorCod" %in% colnames(result))) {
    numbers <- numbers[-i]
    l <- l - 1
    i <- i - 1
  } else {
    assign(result$IndicadorDsg,as.data.frame(result$Dados))
    d1 <- unnest_longer(result$Dados,col = colnames(result$IndicadorDsg),names_repair = "minimal")
    write_csv(d2,file = paste0("datasets/",numbers[i],".csv"))
  }
   if (i %% 100 == 0) {
      Sys.sleep(60)
  }
}


# pop_2013 <- read_csv("outputs/pop_2013.csv")%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2014 <- read_csv("outputs/pop_2014.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2015 <- read_csv("outputs/pop_2015.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2016 <- read_csv("outputs/pop_2016.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2017 <- read_csv("outputs/pop_2017.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2018 <- read_csv("outputs/pop_2018.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2019 <- read_csv("outputs/pop_2019.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2020 <- read_csv("outputs/pop_2020.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# pop_2021 <- read_csv("outputs/pop_2021.csv", 
#     col_types = cols(dim_4 = col_number(), 
#         valor = col_number()))%>%
#     filter(dim_3_t!="HM")%>%
#     mutate(municip = case_when(
#       geocod=="1113101" ~ "Calheta [R.A. Madeira]",
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]",
#       geocod=="1114501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="1114201" ~ "Lagoa [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#     left_join(linkage_geo, join_by(municip==municip))
# 
# 
# fwrite(pop_2013,file = paste0("datasets/pop_2013.csv"), bom = T)
# 
# fwrite(pop_2014,file = paste0("datasets/pop_2014.csv"), bom = T)
# 
# fwrite(pop_2015,file = paste0("datasets/pop_2015.csv"), bom = T)
# 
# fwrite(pop_2016,file = paste0("datasets/pop_2016.csv"), bom = T)
# 
# fwrite(pop_2017,file = paste0("datasets/pop_2017.csv"), bom = T)
# 
# fwrite(pop_2018,file = paste0("datasets/pop_2018.csv"), bom = T)
# 
# fwrite(pop_2019,file = paste0("datasets/pop_2019.csv"), bom = T)
# 
# fwrite(pop_2020,file = paste0("datasets/pop_2020.csv"), bom = T)
# 
# fwrite(pop_2021,file = paste0("datasets/pop_2021.csv"), bom = T)


```

# Test V1

## Pop censitária - 2021

População por municipio à data do CENSUS 2021

```{r, eval=FALSE}
#| code-fold: true
#| code-summary: "Mostrar Código"
# codigos_df <- read_excel("datasets/ref_geo.xlsx")
# 
# 
numbers <- codigos_df$last4

l <- length(numbers)
for(i in 1:l ){
    result<- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0011626&Dim1=T&Dim2=",numbers[i],"&lang=PT"))
    pop <- as.data.frame(result$Dados$'2021')
   if (i %% 99 == 0) {
      Sys.sleep(15)
   }
  if(i==1){
  d2 <- pop
  }else{
    d2 <- rbind(d2,pop)
  }
}

d2 <- d2 %>%
  mutate(municip = case_when(
      geocod=="1113101" ~ "Calheta [R.A. Madeira]",
      geocod=="1114501" ~ "Calheta [R.A. Açores]",
      geocod=="1114201" ~ "Lagoa [R.A. Açores]",
      TRUE ~ as.character(geodsg)))

fwrite(d2,file = paste0("datasets/pop_base_2021.csv"), bom = T)

```

# Improvements

## Linkage geo

Vlookup in R - Merge function

```{r}
linkage_geo <- read_csv("datasets/linkage_geo.csv")%>%  
  mutate(last_4 = as.character(substr(cod_geo, nchar(cod_geo)-3,nchar(cod_geo))))

linkage_geo_freg <- read_csv2("datasets/categorias_geo_freg.csv")%>%
  select(-municip)%>%
  rename(last_4 =pair)%>%
  left_join(linkage_geo,by = "last_4")

linkage_geo <- linkage_geo %>%
  select(geo, ars, nuts3, aces2, nuts1, nuts2, cod_geo_nuts2002, cod_geo)%>%
  rename(municip="geo")%>%
  mutate(municip= recode(municip, "Calheta"="Calheta [R.A. Madeira]"))%>%
  rename(geocod = "cod_geo")
```

Pivot Individual

```{r, eval=FALSE}
#| code-fold: true
#| code-summary: "Mostrar Código"
d3 <- d2%>%
  select(-dim_3,-dim_4)%>%
  pivot_wider(names_from = dim_4_t,values_from = valor)%>%

write_csv(d3,file = paste0("datasets/pop_base_2021_anos.csv"))
```

Pivot quinquenal

```{r, eval=FALSE}
#| code-fold: true
#| code-summary: "Mostrar Código"

d2$dim_4 <- as.numeric(d2$dim_4)
d2$valor <- as.numeric(d2$valor)
#grupos etários
gr_1  <- c(1)        #<1 ano
gr_2  <- c(2:5)    #0 - 4 anos
gr_3  <- c(6:10)   #5 - 9 anos
gr_4  <- c(11:15)  #10 - 14 anos
gr_5  <- c(16:20)  #15 - 19 anos
gr_6  <- c(21:25)  #20 - 24 anos
gr_7  <- c(26:30)  #25 - 29 anos
gr_8  <- c(31:35)  #30 - 34 anos
gr_9  <- c(36:40)  #35 - 39 anos
gr_10 <- c(41:45)  #40 - 44 anos
gr_11 <- c(46:50) #45 - 49 anos
gr_12 <- c(51:55)  #50 - 55 anos
gr_13 <- c(56:60)  #56 - 59 anos
gr_14 <- c(61:65)  #60 - 65 anos
gr_15 <- c(66:70)  #65 - 69 anos
gr_16 <- c(71:75)  #70 - 74 anos
gr_17 <- c(76:80)  #75 - 80 anos
gr_18 <- c(81:85)  #81 - 85 anos
gr_19 <- c(86:101)  #85 e mais anos
gr_20 <- c("T")  #Totais

munucip_pop_age <- d2 %>%
  mutate(etario = case_when(
    dim_4 %in% gr_1 ~ "<1 ano"
    ,dim_4 %in% gr_2 ~ "0 - 4 anos"
    ,dim_4 %in% gr_3 ~ "5 - 9 anos"
    ,dim_4 %in% gr_4 ~ "10 - 14 anos"
    ,dim_4 %in% gr_5 ~ "15 - 19 anos"
    ,dim_4 %in% gr_6 ~ "20 - 24 anos"
    ,dim_4 %in% gr_7 ~ "25 - 29 anos"
    ,dim_4 %in% gr_8 ~ "30 - 34 anos"
    ,dim_4 %in% gr_9 ~ "35 - 39 anos"
    ,dim_4 %in% gr_10 ~ "40 - 44 anos"
    ,dim_4 %in% gr_11 ~ "45 - 49 anos"
    ,dim_4 %in% gr_12 ~ "50 - 54 anos"
    ,dim_4 %in% gr_13 ~ "55 - 59 anos"
    ,dim_4 %in% gr_14 ~ "60 - 64 anos"
    ,dim_4 %in% gr_15 ~ "65 - 69 anos"
    ,dim_4 %in% gr_16 ~ "70 - 74 anos"
    ,dim_4 %in% gr_17 ~ "75 - 80 anos"
     ,dim_4 %in% gr_18 ~ "81 - 84 anos"
     ,dim_4 %in% gr_19 ~ "85 e mais anos"
     ,dim_4 %in% gr_20 ~ "Total"
   )) %>%
   select(-dim_4,-dim_3,-dim_4_t)%>%
   group_by(etario)%>%
   pivot_wider(names_from = etario,values_from = valor, values_fn =sum)%>%
   rename(Total = "NA")%>%
   replace(is.na(.),0)%>%
   left_join(linkage_geo, by = "municip")

 #Reordenar colunas
 munucip_pop_age2 <- munucip_pop_age[,c(1,2,3,4,24,25,26,27,6,11,15,9,7,8,21,16,10,13,18,14,17,19,12,23,22,5,20)]
#
 munucip_pop_age2 <- munucip_pop_age2%>%
   filter(dim_3_t == "H" | dim_3_t == "M" )
#
 munucip_pop_age <- d2 %>%
   mutate(etario = case_when(
     dim_4 %in% gr_1 ~ "<1 ano"
    ,dim_4 %in% gr_2 ~ "0 - 4 anos"
    ,dim_4 %in% gr_3 ~ "5 - 9 anos"
    ,dim_4 %in% gr_4 ~ "10 - 14 anos"
    ,dim_4 %in% gr_5 ~ "15 - 19 anos"
    ,dim_4 %in% gr_6 ~ "20 - 24 anos"
    ,dim_4 %in% gr_7 ~ "25 - 29 anos"
     ,dim_4 %in% gr_8 ~ "30 - 34 anos"
     ,dim_4 %in% gr_9 ~ "35 - 39 anos"
     ,dim_4 %in% gr_10 ~ "40 - 44 anos"
     ,dim_4 %in% gr_11 ~ "45 - 49 anos"
     ,dim_4 %in% gr_12 ~ "50 - 54 anos"
     ,dim_4 %in% gr_13 ~ "55 - 59 anos"
     ,dim_4 %in% gr_14 ~ "60 - 64 anos"
     ,dim_4 %in% gr_15 ~ "65 - 69 anos"
     ,dim_4 %in% gr_16 ~ "70 - 74 anos"
     ,dim_4 %in% gr_17 ~ "75 - 80 anos"
     ,dim_4 %in% gr_18 ~ "81 - 84 anos"
     ,dim_4 %in% gr_19 ~ "85 e mais anos"
     ,dim_4 %in% gr_20 ~ "Total"
  )) %>%
    select(-dim_4,-dim_3,-dim_4_t)%>%
   filter(dim_3_t %in% c("H", "M") & is.na(etario)==FALSE)%>%
   rename(populacao = valor, sexo = dim_3_t )%>%
   group_by(geocod,municip,sexo,etario )%>%
   summarise(populacao= sum(populacao))%>%
  left_join(linkage_geo, by = "municip")



 fwrite(munucip_pop_age,file = paste0("outputs/munucip_pop_age_long.csv"), bom = T)
fwrite(munucip_pop_age2,file = paste0("outputs/munucip_pop_age_wide.csv"), bom = T)
```

## Teste V1.1 - Indicador 0008273

População residente (N.º) por Local de residência (NUTS - 2013), Sexo e Grupo etário; Anual - 2011- 2020

```{r ,eval=FALSE}
#| code-fold: true
#| code-summary: "Mostrar Código"

codigos_df <- read_excel("datasets/ref_geo.xlsx")
# &Dim2=", numbers[i], "
numbers <-linkage_geo$cod_geo

anos_cod <- c("pop_2011","pop_2012","pop_2013","pop_2014","pop_2015","pop_2016","pop_2017","pop_2018","pop_2019","pop_2020")

years <- c("2011","2012","2013","2014","2015","2016","2017","2018","2019","2020")

l <- length(numbers)

y <- length(years)

t <- length(anos_cod)

result_list <- list()

for (i in 1:l) {
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0008273&Dim1=T&Dim2=", numbers[i],"&lang=PT"))
  for (i in 1:y) {
    pop <- as.data.frame(result$Dados)
    pop <- pop %>%
          unnest(years[i])%>%
          select(geocod,geodsg,dim_3,dim_3_t,dim_4,dim_4_t,valor)
    result_list[[anos_cod[i]]] <- rbind(result_list[[anos_cod[i]]], pop)
  }
  if (i %% 100 == 0) {
    Sys.sleep(60)
  }
  Sys.Sleep(2)
}
for (i in 1:y) {
  assign(anos_cod[i], result_list[[anos_cod[i]]])%>% mutate(municip = case_when(
      geocod=="3003101" ~ "Calheta [R.A. Madeira]",
      geocod=="2004501" ~ "Calheta [R.A. Açores]",
      geocod=="2004201" ~ "Lagoa [R.A. Açores]",
      TRUE ~ as.character(geodsg)))%>%fwrite(file = paste0("outputs/",anos_cod[i],".csv"), bom = T)
}

```

```{r ,include=FALSE, eval=FALSE}
# Teste 1.2 - 

# População residente (N.º) por Local de residência (NUTS - 2013), Sexo e Grupo etário; Anual - 2011- 2020
numbers <-linkage_geo$cod_geo_nuts2002
numbers

anos_cod <- c("pop_2001","pop_2002","pop_2003","pop_2004","pop_2005","pop_2006","pop_2007","pop_2008","pop_2009","pop_2010")

years <- c("2001","2002","2003","2004","2005","2006","2007","2008","2009","2010")

l <- length(numbers)

y <- length(years)

result_list <- list()

for (i in 1:l) {
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=0003182&Dim1=T&Dim2=", numbers[i], "&lang=PT"))
  for (i in 1:y) {
    pop <- as.data.frame(result$Dados)
    pop <- pop %>%
          unnest(years[i])%>%
          select(geocod,geodsg,dim_3,dim_3_t,dim_4,dim_4_t,valor)
    result_list[[anos_cod[i]]] <- rbind(result_list[[anos_cod[i]]], pop)
  }
  if (i %% 100 == 0) {
    Sys.sleep(60)
  }
}
for (i in 1:y) {
  assign(anos_cod[i], result_list[[anos_cod[i]]])%>% mutate(municip = case_when(
      geocod=="3003101" ~ "Calheta [R.A. Madeira]",
      geocod=="2004501" ~ "Calheta [R.A. Açores]",
      geocod=="2004201" ~ "Lagoa [R.A. Açores]",
      TRUE ~ as.character(geodsg)))%>%fwrite(file = paste0("outputs/",anos_cod[i],".csv"), bom = T)
}
```

# Extrator Universal de Indicadores do INE para Diagnóstico - Municipio, NUTSIII, NUTSII e NUTSI - V2.0 - Faster, Stronger, Better

O que é suposto:

Definir indicadores a extrair - variável indicador - colocar entre aspas

Pode ser possível extrair os últimos x observacoes - Definido pela variável X

```{r, include=FALSE}
linkage_geo <- read_csv("datasets/linkage_geo.csv")

linkage_geo <- linkage_geo %>%
  select(geo, ars, nuts3, aces2, nuts1, nuts2, cod_geo_nuts2002, cod_geo)  %>%
  rename(municip="geo")%>%
  mutate(municip= recode(municip, "Calheta"="Calheta [R.A. Madeira]"))

#TOTAL DE INDICADORES

Indicadores <- read_excel("datasets/Indicadores.xlsx", skip = 14)

Indicadores <- Indicadores %>%
  filter(`Disponível no Portal`== "Sim")

#indicador <- Indicadores$`Código de difusão`

#DEFINIR INDICADORES A RETIRAR

indicador <- c("0008614","0009817") 

#TERMO DE DESAGREGACAO POR LOCALIZACAO GEOGRAFICA
desag <- "&Dim2="

#CODIGOS GEOGRAFICOS NUTSIII PARA 2012 e 2002
cod_2002 <-linkage_geo$cod_geo_nuts2002
cod_2002 <- cod_2002[! cod_2002 %in% c("9999999", "0")]
cod_2014 <- linkage_geo$geocod
cod_2014 <- cod_2014[! cod_2014 %in% c("9999999", "0")]

#CODIGOS PARA NUTSII
nuts_ii_cod <- c("PT","11","16","17","18","19","20","30")

#DEFINIR ANOS A RETIAR Minimo 2
obs_back <- 10

# DEFINICOES BASEADO NO COLOCADO EM CIMA

a <- length(indicador)

b <- length(cod_2014) 

c <- length(nuts_ii_cod)

#A API DO INE TEM UM LIMITE DE REQUESTS LOGO E CRIADO UM VALOR QUE VAI AUMENTANDO COM AS REQUESTS QUE SAO FEITAS
 
counter <- 1

#LIMPA A ESTRACAO ANTERIOR
result_list <- list()

#FUNCAO DE SLEEP - funciona se sleep e 60, 30, 20, 10, 

sleep <- function(z){
  if (z %% 100 == 0) {
    Sys.sleep(5)
    z <- 1
  }else{
      z <- z+1
  }
} 
```

```{r, include=FALSE}
# save_to_result_list <- function(y){
#   #Segundo loop baseado na desagregação maxima conseguida
#     colunas_nanos <- colnames(dados)
#     num_colunas <- length(colunas_nanos)
#     obs_back  <- as.numeric(colunas_nanos[num_colunas])
#     if(year_back > num_colunas){
#         x <- num_colunas
#     }else{
#       x <-  year_back
#     }
#     obs_back s <- as.character(c((obs_back -x):(obs_back )))
#     each_df <- y %>%
#       select(obs_back s[1])%>%
#       unnest(obs_back s[1])
#     colunas_por_ano <- colnames(each_df)
#     for (i in 1:x) {
#     #ver e retirar os nomes das colunas de cada ano para o select
#     dados1 <- dados %>%
#         unnest(obs_back s[i])%>%
#         select(all_of(colunas_por_ano))
#     result_list[[obs_back s[i]]] <- rbind(result_list[[obs_back s[i]]], dados1)
#     }
#     return(obs_back )
#     return(x)
#     return(result_list)
# }
# 
# write_output <- function(v){
#   x <- length(as.data.frame(v))
#   for (i in 1:x) {
#     nomedf <- paste0(indicador_atual,"_",obs_back s[i],"_",agreg)
#     full_df <- v[[obs_back s[i]]]%>% 
#       mutate(municip = case_when(
#       geocod=="3003101" ~ "Calheta [R.A. Madeira]", 
#       geocod=="2004501" ~ "Calheta [R.A. Açores]",
#       geocod=="2004201" ~ "Lagoa [R.A. Açores]",
#       TRUE ~ as.character(geodsg)))%>%
#       fwrite(file = paste0("outputs/",nomedf,".csv"), bom = T)
#   }
#   result_list <- list()
# }
# 
```

-   Pensar em Refazer com o flatten command

    -   Ainda por resolver\_

```{r, eval=FALSE}
#Falta codigo de debugging

for (k in 1:a) {
  #COMECA POR LER O INDICADOR A RETIRAR
  indicador_atual <- indicador[k]
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO DE 2014
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_2014[79], "&lang=PT"))
  result <- as.data.frame(result)
  #OS DADOS DO INE VEM COM MI E DADOS - PARA A EXTRACAO
  if (("IndicadorCod" %in% colnames(result))){ 
  for (w in 1:b) {
  #retirar indicador com desagregação municipio 2014
  counter <- sleep(counter)
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_2014[w], "&lang=PT"))
  agreg <- "NUTSIII"
  dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_nome <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_nome2 <-  obs_nome[-i]
    dados1 <- dados %>%
        unnest(obs_nome[i])%>%
        select(-all_of(obs_nome2))
    result_list[[obs_nome[i]]] <- bind_rows(result_list[[obs_nome[i]]], dados1)
  Sys.sleep(1)
    }}
    if (w %% 100 == 0) {
      print(cod_2014[w])
   }
    }
  else if(length(result_list)==0){
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO DE 2002
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",desag, cod_2002[1], "&lang=PT"))
  result <- as.data.frame(result)
  if (("IndicadorCod" %in% colnames(result))) {
  #retirar indicador com desagregação municipio 2002
  for (e in 1:b) {
  counter <- sleep(counter)
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",desag, cod_2002[e], "&lang=PT"))
  agreg <- "NUTSIII"
  dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_nome <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_nome2 <-  obs_nome[-i]
    dados1 <- dados %>%
        unnest(obs_nome[i])%>%
        select(-all_of(obs_nome2))
    result_list[[obs_nome[i]]] <- bind_rows(result_list[[obs_nome[i]]], dados1)
  Sys.sleep(1)
    }}
    if (e %% 100 == 0) {
      print(cod_2014[e])
   }
  }
  }
  else if(length(result_list)==0){
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO DE NUTSII
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",desag, nuts_ii_cod[1], "&lang=PT"))
  result <- as.data.frame(result)
  if (("IndicadorCod" %in% colnames(result))) {
  #retirar indicador com desagregação NUTSII
  for (r in 1:c) {
  counter <- sleep(counter)
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual ,"&Dim1=T",desag, nuts_ii_cod[r], "&lang=PT"))
  agreg <- "NUTSII"
  dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_nome <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_nome2 <-  obs_nome[-i]
    dados1 <- dados %>%
        unnest(obs_nome[i])%>%
        select(-any_of(obs_nome2))
    result_list[[obs_nome[i]]] <- bind_rows(result_list[[obs_nome[i]]], dados1)
  Sys.sleep(1)
    }}
  }
  }
  else{
  counter <- sleep(counter)
  #TESTA A DESAGREGAGACAO NACIONAL OU FORA DO PADRAO
  result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T&lang=PT"))
  if (("IndicadorCod" %in% colnames(result))) {
  #retirar indicador sem desagragação
  agreg <- "nacional"
  result <- as.data.frame(result)
   dados <- as.data.frame(result$Dados)
  colunas_nanos <- colnames(dados)
    num_colunas <- length(colunas_nanos)
    if(obs_back > num_colunas){
        x <- num_colunas
    }else{
      x <-  obs_back
    }
    obs_nome <- as.character(c(colunas_nanos[(num_colunas-x):(num_colunas)]))
    for (i in 1:x) {
    #ver e retirar os nomes das colunas de cada ano para o select
    obs_nome2 <-  obs_nome[-i]
    dados1 <- dados %>%
        unnest(obs_nome[i])%>%
        select(-all_of(obs_nome2))
    result_list[[obs_nome[i]]] <- bind_rows(result_list[[obs_nome[i]]], dados1)
  Sys.sleep(1)
    }}
  }
  if (length(result_list)!=0){
     x <- length(result_list)
    for (i in 1:x) {
      nomedf <- paste0(indicador_atual,"_",obs_nome[i],"_",agreg)
      assign(paste0("full_df"), as.data.frame(result_list[[obs_nome[i]]])%>% 
      select(-any_of(colunas_nanos))%>%left_join(linkage_geo, by="geocod"))
      fwrite(full_df, file = paste0("outputs/",nomedf,".csv"), bom = T)
  }
  }
  if (k == k) {
    print(indicador_atual)
    result_list <- list()
   }
}
```

## Testing a rejoin code

```{r, echo=FALSE}
# Get a list of file names
file_names <- list.files(path = "outputs", pattern = ".*\\.csv")

# Initialize a list to store the data frames
df_list <- list()
#FOR LOOP
for (file_name in file_names) {
  # Split the file name into its components
  components <- strsplit(file_name, c("_"))[[1]]
  
    # Remove the ".csv" extension from the last component
  last_component <- sub(".csv", "", components[length(components)])
  components[length(components)]
  # Replace the last component in the components vector
  components[length(components)] <- last_component
  # Assign the components to variables
  indicador <- components[1]
  year <- components[2]
  aggregation <- components[3]
  
  # Load the file into a data frame
  df <- read.csv(file.path("outputs", file_name))
  
  # Add columns for year and aggregation
  df <- cbind(df, year = year, aggregation = aggregation)
  
  # Check if a data frame for this indicator already exists
  if (!(indicador %in% names(df_list))) {
    # If not, create a new data frame for this indicator
    df_list[[indicador]] <- df
  } else {
    # If it does, use rbind to combine the data frames
    df_list[[indicador]] <- rbind(df_list[[indicador]], df)
  }
}

# Write each data frame to a separate CSV file
for (df_name in names(df_list)) {
  df <- df_list[[df_name]]
  write.csv(df, file.path("outputs", paste0(df_name, ".csv")))
}



#MAP FUNCTION DOES NOT WORK

# # Use map to process each file name
# map(file_names, function(file_name, df_list) {
#   # Split the file name into its components
#   components <- strsplit(file_name, "_")[[1]]
#   
#   # Assign the components to variables
#   indicador <- components[1]
#   year <- components[2]
#   aggregation <- components[3]
#   
#   # Load the file into a data frame
#   df <- read.csv(file.path("outputs", file_name))
#   
#   # Add columns for year and aggregation
#   df <- cbind(df, year = year, aggregation = aggregation)
#   # Check if a data frame for this indicator already exists
#   if (!(indicador %in% names(df_list))) {
#     # If not, create a new data frame for this indicator
#     df_list[[indicador]] <- df
#   } else {
#     # If it does, use rbind to combine the data frames
#     df_list[[indicator]] <- rbind(df_list[[indicator]], df)
#   }
# }, df_list)
```

## Extrator Universal para indicadores com Freguesia - Confirmar - Ainda por fazer - ponderar fazer?

```{r include=FALSE}
# Get a list of file names


# linkage_geo_freg <- read_csv2("datasets/categorias_geo_freg.csv")%>%
#   select(-municip)%>%
#   rename(last_4 =pair)%>%
#   left_join(linkage_geo,by = "last_4" )
# 
# 
# cod_6 <- linkage_geo_freg$Código
# 
# indicador <- c("0003182")
# 
# for (i in 1:a) {
#   indicador_atual <- indicador[i]
#   counter <- sleep(counter)
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_6[79], "&lang=PT"))
#   result <- as.data.frame(result)
#   if (("IndicadorCod" %in% colnames(result))){ 
#   for (w in 1:b) {
#   #retirar indicador com desagregação municipio 2014
#   counter <- sleep(counter)
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, cod_6[w], "&lang=PT"))
#   agreg <- "freguesia"
#   result <- as.data.frame(result)
#   colunas_nanos <- colnames(dados)
#     num_colunas <- length(colunas_nanos)
#     obs_back  <- as.numeric(colunas_nanos[num_colunas])
#     if(year_back > num_colunas){
#         x <- num_colunas
#     }else{
#       x <-  year_back
#     }
#     obs_back s <- as.character(c((obs_back -x):(obs_back )))
#     each_df <- y %>%
#       select(obs_back s[1])%>%
#       unnest(obs_back s[1])
#     colunas_por_ano <- colnames(each_df)
#     for (i in 1:x) {
#     #ver e retirar os nomes das colunas de cada ano para o select
#     dados1 <- dados %>%
#         unnest(obs_back s[i])%>%
#         select(all_of(colunas_por_ano))
#     result_list[[obs_back s[i]]] <- rbind(result_list[[obs_back s[i]]], dados1)
#   Sys.sleep(2)
#     }}
#     if (w %% 100 == 0) {
#       print(cod_6[w])
#    }
#     }
#   else{
#   counter <- sleep(counter)
#   result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T&lang=PT"))
#   if (("IndicadorCod" %in% colnames(result))) {
#   #retirar indicador sem desagragação
#   agreg <- "nacional"
#   result <- as.data.frame(result)
#     dados <- as.data.frame(result$Dados)
#   colunas_nanos <- colnames(dados)
#     num_colunas <- length(colunas_nanos)
#     obs_back  <- as.numeric(colunas_nanos[num_colunas])
#     if(year_back > num_colunas){
#         x <- num_colunas
#     }else{
#       x <-  year_back
#     }
#     obs_back s <- as.character(c((obs_back -x):(obs_back )))
#     each_df <- dados %>%
#       select(obs_back s[1])%>%
#       unnest(obs_back s[1])
#     colunas_por_ano <- colnames(each_df)
#     for (i in 1:x) {
#     #ver e retirar os nomes das colunas de cada ano para o select
#     dados1 <- dados %>%
#         unnest(obs_back s[i])%>%
#         select(all_of(colunas_por_ano))
#     result_list[[obs_back s[i]]] <- rbind(result_list[[obs_back s[i]]], dados1)
#   Sys.sleep(2)
#   }
#   }
#   }
#   if (length(result_list)!=0){
#      x <- length(result_list)
#     for (i in 1:x) {
#       nomedf <- paste0(indicador_atual,"_",obs_back s[i],"_",agreg)
#       full_df <- result_list[[obs_back s[i]]]%>% 
#       fwrite(file = paste0("outputs/",nomedf,".csv"), bom = T)
#   }
#   }
#   if (i == i) {
#       print(indicador_atual)
#    }
# }

        # obs_nome <- as.character(c(colunas_nanos[(num_colunas-x+1):(num_colunas)]))
        # i <- 1
        # for (i in 1:x) {
        #   #ver e retirar os nomes das colunas de cada ano para o select
        #   obs_nome2<-obs_nome[-i]
        #   dados1<- dados %>%
        #     unnest(obs_nome[i])%>%
        #     select(-all_of(obs_nome2))
        # 
        #   result_list[[obs_nome[i]]] <- bind_rows(result_list[[obs_nome[i]]], dados1)
        #   Sys.sleep(1)
```

as.character(geo_ref_by)

```{r}
#indicadores é o vetor com os indicadores
#largest_area- filtered dataframe with all codes needed to run
#obs_back- número de observações
  indicadores <- c("0008711")
  obs_back <- 10
  result_list <- list()
  largest_area <- geolinkage_aces
#FUNCAO DE SLEEP - funciona se sleep e 60, 30, 20, 10, 

sleep <- function(z){
  if (z %% 100 == 0) {
    Sys.sleep(5)
    z <- 1
  }else{
      z <- z+1
  }
} 


ine.get <- function(indicadores,largest_area,obs_back,result_list) {

  a <- length(indicadores)
  dicofre_2013 <- unique(largest_area$dicofre_2013)
  municipio_2013 <- unique(largest_area$municipio_2013_cod)
  municipio_2002 <- unique(largest_area$municipio_2002_cod)
  nuts_3_2013 <- unique(largest_area$nuts3_2013_cod)
  nuts_3_2002 <- unique(largest_area$nuts3_2002_cod)
  nuts_2_2002 <- unique(largest_area$nuts2_2013_cod)
  nuts_1 <- unique(largest_area$nuts2_2013_cod)
  
  counter <- 0
  #Existem 2 desagregacoes que estao hard-coded porque sao iguais entre 2013 e 2002
  test <- c("&Dim2=11102&lang=PT",  #Testa a desagregação por freguesias
              "&Dim2=16E0111&lang=PT",#Testa a desagregação por municipio 2013
              "&Dim2=1610111&lang=PT",#Testa a desagregação por municipio 2002
              "&Dim2=16E&lang=PT",    #Testa a desagregação por NUTSIII 2013
              "&Dim2=161&lang=PT",    #Testa a desagregação por NUTSIII 2002
              "&Dim2=16&lang=PT",     #Testa a desagregação por NUTSII 2013
              ""                      #Testa a desagregação por NUTSI ou sem padrão 
              )
  codes_list <- list(dicofre_2013,municipio_2013,municipio_2002,nuts_3_2013,nuts_3_2002,nuts_2_2002,"")
  b_list <- list(length(dicofre_2013),length(municipio_2013),length(municipio_2002),length(nuts_3_2013),length(nuts_3_2002),length(nuts_2_2002),1)
  agreg_list <- list("Freguesia","Municipio","Municipio","NUTSIII","NUTSIII","NUTSII","Nacional")
  desag_v <- c("&Dim2=","&Dim2=","&Dim2=","&Dim2=","&Dim2=","&Dim2=","")
  # geo_ref_df <- list(dicofre_2013,municipio_2013_cod,municipio_2002_cod,nuts3_2013_codnuts3_2002_cod,nuts2_2013_cod,nuts_1)
  geo_ref_by_v <- c("dicofre_2013",
                  "municipio_2013_cod",
                  "municipio_2002_cod",
                  "nuts3_2013_cod",
                  "nuts3_2002_cod",
                  "nuts2_2013_cod",
                  "nuts_1_2013_cod")
  for (k in 1:a) {
    #COMECA POR LER O INDICADOR A RETIRAR
    indicador_atual <- indicadores[k]
    counter <- sleep(counter)
    result <- list()
    for (k in 1:length(test)){
      counter <- sleep(counter)
      test[[k]] <- as.data.frame(fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",test[k],"&lang=PT")))
    }
    r <- 1
    b <- b_list[[1]]
    codes <- codes_list[[1]]
    agreg <- agreg_list[[1]]
    desag <- desag_v[1]
    # geo_ref_df <- geo_ref[[1]]
    geo_ref_by <- geo_ref_by_v[1]
    while("Falso" %in% colnames(test[[r]]$Sucesso)){
      r <- r + 1
      b <- b_list[[r]]
      codes <- codes_list[[r]]
      agreg <- agreg_list[[r]]
      desag <- desag_v[r]
      # geo_ref_df <- geo_ref[[r]]
      geo_ref_by <- geo_ref_by_v[r]
    }
    for (w in 1:b){
        counter <- sleep(counter)
        result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, codes[w],"&lang=PT"))
        dados <- as.data.frame(result$Dados)
        colunas_nanos <- colnames(dados)
        num_colunas <- length(colunas_nanos)
        if(obs_back > num_colunas){
          x <-num_colunas
        }else{
          x <-obs_back
        }
        # Get column names for years of interest
        obs_cols <- as.character(c(colunas_nanos[(num_colunas-x+1):(num_colunas)]))
        df_all <- data.frame()
        # Loop over years
        for (obs in obs_cols) {
          # Remove all columns except current year
          df <- dados %>%
            unnest(!!sym(obs))%>%
            select(-any_of(colunas_nanos))%>%
            mutate(obs=as.character(obs))%>%
            left_join(largest_area, by=c("geocod" = as.character(geo_ref_by)),  multiple = "first" )
          # Add data frame to list
          df_all <- bind_rows(df_all, df)
          # Pause for 1 second
          Sys.sleep(1)
        }
        if(w==1){
          result_list[[indicador_atual]] <- df_all
        }
        else{
    result_list[[indicador_atual]] <- bind_rows(result_list[[indicador_atual]], df_all)
        }
      }
  return(result_list)
  }
}  
        #still working on the END
    # if (length(result_list)!=0){
    #   x <- length(result_list)
    #   for (i in 1:x) {
    #     nomedf <- paste0(indicador_atual,"_",obs_nome[i],"_",agreg)
    #     assign(paste0("full_df"), as.data.frame(result_list[[obs_nome[i]]])%>%
    #              select(-any_of(colunas_nanos)))
                 # left_join(linkage_geo, by="geocod"))
        # fwrite(full_df, file = paste0("outputs/",nomedf,".csv"), bom = T)
    # }
```

left_join(largest_area, by("geocod" = as.character(geo_ref_by)))

```{r}
setwd("C:/Users/jdrdionisio/Desktop/RProjects/Projects/INE/INE_API/")

geolinkage_path <- "datasets/geolinkage_aces_2022.csv"
geolinkage_aces <- read_csv(geolinkage_path,col_types = cols(.default = "c"))
colnames(geolinkage_aces) 
# result_list <- list()
largest_area <- geolinkage_aces 
obs_back <- 10
indicadores <- c("0008711",	0008079)
result_list <- list()
# result_list <- list()
# largest_area <- geolinkage_aces %>%
#   filter(aces_2022=="ACES Baixo Mondego")

sleep <- function(z){
  if (z %% 100 == 0) {
    Sys.sleep(5)
    z <- 1
  }else{
    z <- z+1
  }
  return(z)
  }

# ine.get <- function(indicadores,largest_area,obs_back,result_list) {
  a <- length(indicadores)
  dicofre_2013 <- unique(largest_area$dicofre_2013)
  municipio_2013 <- unique(largest_area$municipio_2013_cod)
  municipio_2002 <- unique(largest_area$municipio_2002_cod)
  nuts_3_2013 <- unique(largest_area$nuts3_2013_cod)
  nuts_3_2002 <- unique(largest_area$nuts3_2002_cod)
  nuts_2_2013 <- unique(largest_area$nuts2_2013_cod)
  nuts_1 <- unique(largest_area$nuts1_2013_cod)
  counter <- 0
  #Existem 2 desagregacoes que estao hard-coded porque sao iguais entre 2013 e 2002
  testd <- c("&Dim2=11102&lang=PT",  #Testa a desagregação por freguesias
            "&Dim2=16E0111&lang=PT", #Testa a desagregação por municipio 2013
            "&Dim2=1610111&lang=PT", #Testa a desagregação por municipio 2002
            "&Dim2=16E&lang=PT",     #Testa a desagregação por NUTSIII 2013
            "&Dim2=161&lang=PT",     #Testa a desagregação por NUTSIII 2002
            "&Dim2=16&lang=PT",      #Testa a desagregação por NUTSII 2013
            "&lang=PT"               #Testa a desagregação por NUTSI ou sem padrão 
  )
  codes_list <- list(dicofre_2013,municipio_2013,municipio_2002,nuts_3_2013,nuts_3_2002,nuts_2_2013,"")
  b_list <- list(length(dicofre_2013),length(municipio_2013),length(municipio_2002),length(nuts_3_2013),length(nuts_3_2002),length(nuts_2_2013),1)
  agreg_list <- list("Freguesia","Municipio","Municipio","NUTSIII","NUTSIII","NUTSII","Nacional")
  desag_v <- c("&Dim2=","&Dim2=","&Dim2=","&Dim2=","&Dim2=","&Dim2=","")
  # geo_ref_df <- list(dicofre_2013,municipio_2013_cod,municipio_2002_cod,nuts3_2013_codnuts3_2002_cod,nuts2_2013_cod,nuts_1)
  geo_ref_by_v <- c("dicofre_2013",
                    "municipio_2013_cod",
                    "municipio_2002_cod",
                    "nuts3_2013_cod",
                    "nuts3_2002_cod",
                    "nuts2_2013_cod",
                    "nuts1_2013_cod")
  for (i in 1:a) {
    #COMECA POR LER O INDICADOR A RETIRAR
    indicador_atual <- indicadores[i]
    counter <- sleep(counter)
    test <- list()
    for (k in 1:length(testd)){
      counter <- sleep(counter)
      test[[k]] <- as.data.frame(fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",testd[k])))
    }
    r <- 1
    b <- b_list[[1]]
    codes <- codes_list[[1]]
    agreg <- agreg_list[[1]]
    desag <- desag_v[1]
    # geo_ref_df <- geo_ref[[1]]
    geo_ref_by <- geo_ref_by_v[1]
    while("Falso" %in% colnames(test[[r]]$Sucesso)){
      r <- r + 1
      b <- b_list[[r]]
      codes <- codes_list[[r]]
      agreg <- agreg_list[[r]]
      desag <- desag_v[r]
      # geo_ref_df <- geo_ref[[r]]
      geo_ref_by <- geo_ref_by_v[r]
    }
    for (w in 1:b){
      counter <- sleep(counter)
      result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, codes[w],"&lang=PT"))
      dados <- as.data.frame(result$Dados)
      colunas_nanos <- colnames(dados)
      num_colunas <- length(colunas_nanos)
      if(obs_back > num_colunas){
        x <-num_colunas
      }else{
        x <-obs_back
      }
      # Get column names for years of interest
      obs_cols <- as.character(c(colunas_nanos[(num_colunas-x+1):(num_colunas)]))
      df_all <- data.frame()
      # Loop over years
      for (obs in obs_cols) {
        # Remove all columns except current year
        df <- dados %>%
          unnest(!!sym(obs))%>%
          select(-any_of(colunas_nanos))%>%
          mutate(obs=as.character(obs))%>%
          left_join(largest_area, by=c("geocod" = as.character(geo_ref_by)),  multiple = "first" )
        # Add data frame to list
        df_all <- bind_rows(df_all, df)
        # Pause for 1 second
        Sys.sleep(1)
      }
      if(w==1){
        result_list[[indicador_atual]] <- df_all
      }
      else{
        result_list[[indicador_atual]] <- bind_rows(result_list[[indicador_atual]], df_all)
      }
      # return(result_list)
    }
  }
  # return(result_list)
# }  
result_list

# result_list <- ine.get(indicador,largest,obs_back,result_list)

#Freguesia
#Municipio
desag <- seq(1:20)
names(desag)
#NUTS2002
#NUTSI ou padrao
colnames(geolinkage_aces)
colnames(geolinkage_aces[2:20])
```

```{r}
result_list <- list()
largest_area <- geolinkage_aces %>%
  filter(aces_2022=="ACES Baixo Mondego")

geo_ref_df <- list(largest_area,largest_area[2:20],largest_area[2:20],largest_area[c(7:20)],largest_area[c(7:20)],largest_area[c(10:15,19,20)],largest_area[c(12:15)])

indicadores <- "0008614"
obs_back <- 2
largest_area <- geolinkage_aces %>%
  filter(aces_2022=="ACES Baixo Mondego")

# ine.get <- function(indicadores,largest_area,obs_back,result_list) {
  a <- length(indicadores)
  dicofre_2013 <- unique(largest_area$dicofre_2013)
  municipio_2013 <- unique(largest_area$municipio_2013_cod)
  municipio_2002 <- unique(largest_area$municipio_2002_cod)
  nuts_3_2013 <- unique(largest_area$nuts3_2013_cod)
  nuts_3_2002 <- unique(largest_area$nuts3_2002_cod)
  nuts_2_2013 <- unique(largest_area$nuts2_2013_cod)
  nuts_1 <- unique(largest_area$nuts1_2013_cod)
  counter <- 0
  #Existem 2 desagregacoes que estao hard-coded porque sao iguais entre 2013 e 2002
  testd <- c("&Dim2=11102&lang=PT",  #Testa a desagregação por freguesias
             "&Dim2=16E0111&lang=PT",#Testa a desagregação por municipio 2013
             "&Dim2=1610111&lang=PT",#Testa a desagregação por municipio 2002
             "&Dim2=16E&lang=PT",    #Testa a desagregação por NUTSIII 2013
             "&Dim2=161&lang=PT",    #Testa a desagregação por NUTSIII 2002
             "&Dim2=16&lang=PT",     #Testa a desagregação por NUTSII 2013
             "&lang=PT"                      #Testa a desagregação por NUTSI ou sem padrão 
  )
  codes_list <- list(dicofre_2013,municipio_2013,municipio_2002,nuts_3_2013,nuts_3_2002,nuts_2_2013,"")
  b_list <- list(length(dicofre_2013),length(municipio_2013),length(municipio_2002),length(nuts_3_2013),length(nuts_3_2002),length(nuts_2_2013),1)
  agreg_list <- list("Freguesia","Municipio","Municipio","NUTSIII","NUTSIII","NUTSII","Nacional")
  desag_v <- c("&Dim2=","&Dim2=","&Dim2=","&Dim2=","&Dim2=","&Dim2=","")
  geo_ref_df <- list(largest_area,largest_area[2:20],largest_area[2:20],largest_area[c(7:20)],largest_area[c(7:20)],largest_area[c(10:15,19,20)],largest_area[c(12:15)])
  geo_ref_by_v <- c("dicofre_2013",
                    "municipio_2013_cod",
                    "municipio_2002_cod",
                    "nuts3_2013_cod",
                    "nuts3_2002_cod",
                    "nuts2_2013_cod",
                    "nuts1_2013_cod")
  for (i in 1:a) {
    #COMECA POR LER O INDICADOR A RETIRAR
    indicador_atual <- indicadores[i]
    counter <- sleep(counter)
    test <- list()
    for (k in 1:length(testd)){
      counter <- sleep(counter)
      test[[k]] <- as.data.frame(fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T",testd[k])))
    }
    r <- 1
    b <- b_list[[1]]
    codes <- codes_list[[1]]
    agreg <- agreg_list[[1]]
    desag <- desag_v[1]
    geo_ref_df <- geo_ref_df[[1]]
    geo_ref_by <- geo_ref_by_v[1]
    while("Falso" %in% colnames(test[[r]]$Sucesso)){
      r <- r + 1
      b <- b_list[[r]]
      codes <- codes_list[[r]]
      agreg <- agreg_list[[r]]
      desag <- desag_v[r]
      geo_ref_df <- geo_ref_df[[r]]
      geo_ref_by <- geo_ref_by_v[r]
    }
    for (w in 1:b){
      counter <- sleep(counter)
      result <- fromJSON(paste0("https://www.ine.pt/ine/json_indicador/pindica.jsp?op=2&varcd=",indicador_atual,"&Dim1=T", desag, codes[w],"&lang=PT"))
      dados <- as.data.frame(result$Dados)
      colunas_nanos <- colnames(dados)
      num_colunas <- length(colunas_nanos)
      if(obs_back > num_colunas){
        x <-num_colunas
      }else{
        x <-obs_back
      }
      # Get column names for years of interest
      obs_cols <- as.character(c(colunas_nanos[(num_colunas-x+1):(num_colunas)]))
      df_all <- data.frame()
      # Loop over years
      for (obs in obs_cols) {
        # Remove all columns except current year
        df <- dados %>%
          unnest(!!sym(obs))%>%
          select(-any_of(colunas_nanos))%>%
          mutate(obs=as.character(obs))%>%
          left_join(geo_ref_df, by=c("geocod" = as.character(geo_ref_by)),  multiple = "first" )
        # Add data frame to list
        df_all <- bind_rows(df_all, df)
        # Pause for 1 second
        Sys.sleep(1)
      }
      if(w==1){
        result_list[[indicador_atual]] <- df_all
      }
      else{
        result_list[[indicador_atual]] <- bind_rows(result_list[[indicador_atual]], df_all)
      }
    }
  }
  return(result_list)
# }

result_list <- ine.get(indicador,largest,obs_back,result_list)
```
